# Job Flow Part 2: Queen Reception & Job Creation

**Flow:** Queen HTTP → Job Creation → SSE Channel Setup  
**Date:** November 2, 2025  
**Status:** ✅ COMPLETE

---

## Overview

This document traces the flow from when `queen-rbee` receives the POST request from `rbee-keeper` to when it creates a job and sets up an isolated SSE channel for streaming results.

**HTTP Endpoint:** `POST http://localhost:7833/v1/jobs`

---

## Step 1: HTTP Route Handler

### File: `bin/10_queen_rbee/src/http/jobs.rs`

**HTTP Handler:**
```rust
/// POST /v1/jobs - Create a new job (ALL operations)
///
/// Thin HTTP wrapper that delegates to job_router::create_job().
///
/// Example payloads:
/// - {"operation": "infer", "hive_id": "localhost", "model": "...", "prompt": "..."}
pub async fn handle_create_job(
    State(state): State<SchedulerState>,
    Json(payload): Json<serde_json::Value>,
) -> Result<Json<crate::job_router::JobResponse>, (StatusCode, String)> {
    // Delegate to router
    crate::job_router::create_job(state.into(), payload)
        .await
        .map(Json)
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
}
```

**Location:** Lines 55-64  
**Function:** `handle_create_job()`  
**Purpose:** Receive POST request, delegate to job router

**Key Details:**
- Axum extracts `State` and `Json` automatically
- `payload` is raw `serde_json::Value` (not yet parsed)
- Delegates to `job_router::create_job()` for business logic
- Returns `JobResponse` as JSON

---

## Step 2: State Conversion

### File: `bin/10_queen_rbee/src/http/jobs.rs`

**SchedulerState:**
```rust
#[derive(Clone)]
pub struct SchedulerState {
    /// Registry for managing job lifecycle and payloads
    pub registry: Arc<JobRegistry<String>>,
    
    /// Telemetry registry for live hive/worker state
    pub hive_registry: Arc<queen_rbee_telemetry_registry::TelemetryRegistry>,
}
```

**Conversion to JobState:**
```rust
impl From<SchedulerState> for crate::job_router::JobState {
    fn from(state: SchedulerState) -> Self {
        Self {
            registry: state.registry,
            hive_registry: state.hive_registry,
        }
    }
}
```

**Location:** Lines 25-45  
**Purpose:** Convert HTTP state to router state

**Key Details:**
- `SchedulerState` is HTTP-layer state
- `JobState` is router-layer state
- Conversion is zero-cost (just field mapping)

---

## Step 3: Job Creation

### File: `bin/10_queen_rbee/src/job_router.rs`

**Create Job Function:**
```rust
/// Create a new job and store its payload
///
/// This is the clean public API for job creation.
/// Called by HTTP layer to create jobs.
pub async fn create_job(state: JobState, payload: serde_json::Value) -> Result<JobResponse> {
    // Step 3a: Generate unique job ID
    let job_id = state.registry.create_job();
    
    // Step 3b: Construct SSE URL
    let sse_url = format!("/v1/jobs/{}/stream", job_id);
    
    // Step 3c: Store payload for later execution
    state.registry.set_payload(&job_id, payload);
    
    // Step 3d: Create job-specific SSE channel (isolated)
    observability_narration_core::sse_sink::create_job_channel(job_id.clone(), 1000);
    
    // Step 3e: Emit narration event
    n!("job_create", "Job {} created, waiting for client connection", job_id);
    
    // Step 3f: Return response
    Ok(JobResponse { job_id, sse_url })
}
```

**Location:** Lines 55-67  
**Function:** `create_job()`  
**Purpose:** Create job, set up SSE channel, return job info

**Narration Events:**
- `job_create` — Job created, waiting for client

**Key Details:**
- Job ID is UUID (generated by `JobRegistry`)
- Payload stored as raw JSON (not yet parsed)
- SSE channel created with 1000-message buffer
- Job execution happens LATER (when client connects to SSE)

---

## Step 4: Job Registry

### File: `bin/99_shared_crates/job-server/src/lib.rs`

**Create Job:**
```rust
impl<T> JobRegistry<T> {
    /// Create a new job and return its ID
    pub fn create_job(&self) -> String {
        let job_id = format!("job_{}", uuid::Uuid::new_v4());
        
        let mut jobs = self.jobs.write().unwrap();
        jobs.insert(job_id.clone(), JobState::Pending);
        
        job_id
    }
    
    /// Store payload for a job
    pub fn set_payload(&self, job_id: &str, payload: serde_json::Value) {
        let mut payloads = self.payloads.write().unwrap();
        payloads.insert(job_id.to_string(), payload);
    }
}
```

**Location:** job-server/src/lib.rs  
**Purpose:** Manage job lifecycle and payloads

**Key Details:**
- Job ID format: `job_<uuid>`
- Example: `job_abc123-def456-...`
- Payloads stored in `HashMap<String, serde_json::Value>`
- Thread-safe with `RwLock`

---

## Step 5: SSE Channel Creation

### File: `bin/99_shared_crates/narration-core/src/output/sse_sink.rs`

**Create Job Channel:**
```rust
/// Create a job-specific SSE channel
///
/// This creates an isolated MPSC channel for a single job.
/// The receiver can only be taken once (via take_job_receiver).
pub fn create_job_channel(job_id: String, buffer_size: usize) {
    let (tx, rx) = tokio::sync::mpsc::channel(buffer_size);
    
    // Store sender in global map
    let mut senders = JOB_SENDERS.write().unwrap();
    senders.insert(job_id.clone(), tx);
    
    // Store receiver in global map (will be taken by SSE handler)
    let mut receivers = JOB_RECEIVERS.write().unwrap();
    receivers.insert(job_id, rx);
}
```

**Location:** narration-core/src/output/sse_sink.rs  
**Purpose:** Create isolated SSE channel for job

**Key Details:**
- MPSC channel (multi-producer, single-consumer)
- Buffer size: 1000 messages
- Sender stored globally (for narration events)
- Receiver stored globally (taken by SSE handler)

---

## Step 6: Job Response

### File: `bin/97_contracts/jobs-contract/src/lib.rs`

**JobResponse Type:**
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JobResponse {
    pub job_id: String,
    pub sse_url: String,
}
```

**Example Response:**
```json
{
  "job_id": "job_abc123-def456-789ghi-012jkl",
  "sse_url": "/v1/jobs/job_abc123-def456-789ghi-012jkl/stream"
}
```

**Location:** jobs-contract/src/lib.rs  
**Purpose:** Response sent back to keeper

**Key Details:**
- `job_id` — Unique identifier for tracking
- `sse_url` — Relative path to SSE endpoint
- Client constructs full URL: `http://localhost:7833{sse_url}`

---

## Data Flow Summary

```
POST http://localhost:7833/v1/jobs
    ↓ JSON payload
    ↓
handle_create_job() [http/jobs.rs:55]
    ↓ extract State and Json
    ↓ convert SchedulerState → JobState
    ↓
create_job() [job_router.rs:55]
    ↓
JobRegistry::create_job() [job-server/src/lib.rs]
    ↓ generate UUID
    ↓ job_id = "job_<uuid>"
    ↓
JobRegistry::set_payload() [job-server/src/lib.rs]
    ↓ store raw JSON payload
    ↓
create_job_channel() [narration-core/src/output/sse_sink.rs]
    ↓ create MPSC channel (1000 buffer)
    ↓ store sender (for narration)
    ↓ store receiver (for SSE)
    ↓
n!("job_create") [job_router.rs:64]
    ↓ emit narration event
    ↓
Return JobResponse
    ↓ { job_id, sse_url }
    ↓
HTTP 200 OK (JSON response)
    ↓
Back to keeper (Part 1)
```

---

## Narration Events (Part 2)

| Event | Action | Message | Location |
|-------|--------|---------|----------|
| `job_create` | Job created | "Job {job_id} created, waiting for client connection" | job_router.rs:64 |

---

## Key Files Referenced

| File | Purpose | Key Functions |
|------|---------|---------------|
| `bin/10_queen_rbee/src/http/jobs.rs` | HTTP handler | `handle_create_job()` |
| `bin/10_queen_rbee/src/job_router.rs` | Job routing | `create_job()` |
| `bin/99_shared_crates/job-server/src/lib.rs` | Job registry | `create_job()`, `set_payload()` |
| `bin/99_shared_crates/narration-core/src/output/sse_sink.rs` | SSE channels | `create_job_channel()` |
| `bin/97_contracts/jobs-contract/src/lib.rs` | API types | `JobResponse` |

---

## State Management

### Job States

```rust
enum JobState {
    Pending,    // Created, not yet executed
    Running,    // Currently executing
    Completed,  // Finished successfully
    Failed,     // Finished with error
    Cancelled,  // Cancelled by user
}
```

**Transitions:**
```
Pending → Running (when client connects to SSE)
Running → Completed (when job finishes)
Running → Failed (when job errors)
Pending/Running → Cancelled (when user cancels)
```

---

## SSE Channel Architecture

### Isolation Pattern

**Each job gets its own isolated channel:**
```
Job 1: Sender → Channel (1000 buffer) → Receiver → SSE Stream 1
Job 2: Sender → Channel (1000 buffer) → Receiver → SSE Stream 2
Job 3: Sender → Channel (1000 buffer) → Receiver → SSE Stream 3
```

**Why Isolated:**
- ✅ No cross-job contamination
- ✅ Independent backpressure
- ✅ Clean cleanup (receiver drop = channel close)
- ✅ No global broadcast complexity

---

## Thread Safety

### Concurrent Job Creation

**Multiple clients can create jobs simultaneously:**
```rust
// JobRegistry uses RwLock for thread-safe access
jobs: Arc<RwLock<HashMap<String, JobState>>>
payloads: Arc<RwLock<HashMap<String, serde_json::Value>>>
```

**SSE channels use RwLock:**
```rust
// Global maps protected by RwLock
JOB_SENDERS: RwLock<HashMap<String, Sender>>
JOB_RECEIVERS: RwLock<HashMap<String, Receiver>>
```

---

## Error Handling

### Possible Errors

**HTTP Layer:**
- Invalid JSON → 400 Bad Request
- Server error → 500 Internal Server Error

**Job Creation:**
- UUID generation failure (extremely rare)
- Channel creation failure (memory exhaustion)

**Error Response:**
```json
{
  "error": "Failed to create job: <reason>"
}
```

---

## Performance Characteristics

### Job Creation Speed

**Typical latency:** <1ms
- UUID generation: ~100ns
- HashMap insert: ~10ns
- Channel creation: ~1µs
- Total: <1ms

### Memory Usage

**Per job:**
- Job state: ~100 bytes
- Payload: variable (typically <1KB)
- SSE channel: ~8KB (1000 × 8 bytes)
- Total: ~9KB per job

---

## Configuration

**SSE Channel Buffer:**
- Default: 1000 messages
- Hardcoded in `job_router.rs:62`
- Prevents memory exhaustion from slow clients

**Job ID Format:**
- Prefix: `job_`
- UUID: v4 (random)
- Example: `job_abc123-def456-789ghi-012jkl`

---

**Next:** [JOB_FLOW_PART_3_JOB_EXECUTION.md](./JOB_FLOW_PART_3_JOB_EXECUTION.md) — Job execution with narration context
