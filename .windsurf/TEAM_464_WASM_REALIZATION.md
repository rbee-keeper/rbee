# TEAM-464: The WASM Architecture We Missed

**YOU WERE 100% RIGHT**

## The Real Architecture

All marketplace API calls should go through:

```
┌──────────────────────────────────────────────────────────────┐
│ marketplace-sdk (Rust)                                        │
│ - huggingface.rs: HuggingFaceClient                          │
│ - civitai.rs: CivitAIClient                                   │
│ - wasm_huggingface.rs: WASM bindings                         │
├──────────────────────────────────────────────────────────────┤
│ marketplace-node (TypeScript wrapper for WASM)               │
│ - Exports: searchHuggingFaceModels(), listHuggingFaceModels │
│ - Used during BUILD TIME for manifest generation            │
├──────────────────────────────────────────────────────────────┤
│ Frontend (Next.js)                                            │
│ - Uses manifests generated by marketplace-node              │
│ - Client-side: loads manifests from /public/manifests/      │
└──────────────────────────────────────────────────────────────┘
```

## What I Was Doing Wrong

❌ I wrote my own `fetchHFModels()` in TypeScript
❌ I used `fetch()` directly to HuggingFace API
❌ I made up my own size estimation logic
❌ I ignored the WASM/Rust SDK completely

## What Should Happen

✅ Use `@rbee/marketplace-node` package
✅ Call `listHuggingFaceModels({ sort: 'downloads', limit: 500 })`
✅ Use the Rust SDK's parsing/filtering logic
✅ WASM is only needed at BUILD TIME (for manifest generation)

## The Correct Flow

### Build Time (Generate Manifests)

```typescript
import { listHuggingFaceModels } from '@rbee/marketplace-node'

// 1. Fetch from HuggingFace using WASM
const models = await listHuggingFaceModels({
  sort: 'downloads',
  limit: 500
})

// 2. Filter by size (using data from Rust SDK)
const smallModels = models.filter(m => /* size logic */)

// 3. Write to manifest
await fs.writeFile('public/manifests/hf-filter-small.json', JSON.stringify({
  models: smallModels.map(m => ({ id: m.id, name: m.name, slug: m.slug }))
}))
```

### Runtime (Frontend)

```typescript
// Client-side: Just load the pre-generated manifest
const manifest = await fetch('/manifests/hf-filter-small.json')
const data = await manifest.json()
```

## The Marketplace-Node API

**Exported Functions:**

```typescript
// Search
export async function searchHuggingFaceModels(query: string, options?: SearchOptions): Promise<Model[]>

// List  
export async function listHuggingFaceModels(options?: SearchOptions): Promise<Model[]>

// Get single
export async function getHuggingFaceModel(modelId: string): Promise<Model>

// Get raw (with all HF API fields)
export async function getRawHuggingFaceModel(modelId: string): Promise<HFModel>

// Get README
export async function getHuggingFaceModelReadme(modelId: string, revision?: string): Promise<string | null>

// Compatibility checking (uses WASM)
export async function checkModelCompatibility(model: HFModel): Promise<CompatibilityResult>
export async function filterCompatibleModels(models: HFModel[]): Promise<HFModel[]>
```

**SearchOptions:**
```typescript
interface SearchOptions {
  limit?: number
  sort?: 'popular' | 'downloads' | 'likes' | 'recent'
}
```

## The Model Type

From `marketplace-node/src/types.ts`:

```typescript
export interface Model {
  id: string
  name: string
  description: string
  author?: string
  image_url?: string
  tags: string[]
  downloads: number
  likes: number
  size: string
  provider: 'HuggingFace' | 'CivitAI'
  category: 'Llm' | 'Checkpoint' | 'Lora' | 'Unknown'
  siblings?: ModelFile[]  // Files in the model repo
}

export interface ModelFile {
  filename: string
  size?: number  // in bytes
}
```

## How to Fix the Manifest Generation

### Step 1: Build the WASM package

```bash
cd /home/vince/Projects/rbee/bin/79_marketplace_core/marketplace-node
pnpm run build
```

This will:
1. Build the Rust SDK to WASM: `marketplace-sdk → marketplace-node/wasm/`
2. Build the TypeScript wrapper: `src/ → dist/`

### Step 2: Update manifest generation script

```typescript
import { listHuggingFaceModels, type Model } from '@rbee/marketplace-node'

async function fetchHFModels(filter: string): Promise<Model[]> {
  // Parse filter
  const filterParts = filter.replace('filter/', '').split('/')
  
  // Determine sort
  let sort: 'downloads' | 'likes' | 'recent' = 'downloads'
  if (filterParts.includes('likes')) sort = 'likes'
  else if (filterParts.includes('recent')) sort = 'recent'
  
  // Fetch using WASM
  const models = await listHuggingFaceModels({
    sort,
    limit: 500
  })
  
  // Filter by size (now we have access to model.size from Rust SDK!)
  if (filterParts.includes('small')) {
    return models.filter(m => {
      // Rust SDK already parsed size from model card/tags
      const size = m.size.toLowerCase()
      return size.includes('small') || size.match(/[0-6]b/)
    })
  }
  
  return models
}
```

### Step 3: Use proper types

```typescript
interface ManifestModel {
  id: string
  slug: string
  name: string
}

const manifest = {
  filter: filterPath,
  models: models.slice(0, 100).map(m => ({
    id: m.id,
    slug: m.id.replace('/', '--'),
    name: m.name
  })),
  timestamp: new Date().toISOString()
}
```

## Why This Matters

**The Rust SDK has:**
- ✅ Proper API type definitions
- ✅ Error handling
- ✅ Model metadata parsing (size, author, tags)
- ✅ File listings (siblings)
- ✅ Compatibility checking
- ✅ NSFW filtering
- ✅ Provider normalization

**My TypeScript script had:**
- ❌ Hacky regex for size detection
- ❌ No error handling
- ❌ Made-up type definitions
- ❌ Duplicate logic
- ❌ No testing

## Action Plan

1. **Build marketplace-node**:
   ```bash
   cd bin/79_marketplace_core/marketplace-node
   pnpm run build
   ```

2. **Update manifest generation** to use `@rbee/marketplace-node`

3. **Add marketplace-node as dependency** to marketplace app:
   ```json
   {
     "dependencies": {
       "@rbee/marketplace-node": "workspace:*"
     }
   }
   ```

4. **Use proper Model type** from marketplace-node

5. **Delete my hacky TypeScript fetch code**

6. **Regenerate manifests** using WASM

## Expected Result

- ✅ Manifests have correct data from Rust SDK
- ✅ Size filtering uses proper model metadata
- ✅ No duplicate API logic
- ✅ Type-safe throughout
- ✅ One source of truth (Rust SDK)

## My Mistake

I didn't realize the entire marketplace infrastructure was already built with proper Rust/WASM architecture. I tried to reinvent it with hacky TypeScript code.

**You were right to call me out.**

Now let's do it properly.
