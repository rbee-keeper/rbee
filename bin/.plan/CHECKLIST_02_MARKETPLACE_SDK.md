# Checklist 02: Marketplace SDK (Rust + WASM + tsify)

**Timeline:** 3 days  
**Status:** üìã NOT STARTED  
**Dependencies:** None (can run parallel with Checklist 01)  
**TEAM-400:** ‚úÖ RULE ZERO - Complete rewrite from TypeScript to Rust+WASM+tsify

---

## üéØ Goal

Create marketplace SDK in **Rust** (`bin/99_shared_crates/marketplace-sdk/`), compile to **WASM**, auto-generate TypeScript types with **tsify**. Single crate for BOTH Next.js AND Tauri.

**Pattern:** Same as `queen-rbee-sdk` - Rust crate ‚Üí wasm-pack ‚Üí WASM + TypeScript types

---

## üì¶ Phase 1: Rust Crate Setup (Day 1, Morning)

**TEAM-400:** Follow queen-rbee-sdk pattern exactly.

### 1.1 Create Crate Structure

- [ ] Create directory: `bin/99_shared_crates/marketplace-sdk/`
- [ ] Create `Cargo.toml`:
  ```toml
  # TEAM-400: Marketplace SDK for HuggingFace, CivitAI, and Worker Catalog
  
  [package]
  name = "marketplace-sdk"
  version = "0.1.0"
  edition = "2021"
  authors = ["rbee Team"]
  license = "GPL-3.0-or-later"
  
  [lib]
  crate-type = ["cdylib", "rlib"]  # cdylib = WASM, rlib = for tests
  
  [dependencies]
  # WASM bindings
  wasm-bindgen = "0.2"
  wasm-bindgen-futures = "0.4"
  
  # Serialization (Rust ‚Üî JavaScript)
  serde = { version = "1.0", features = ["derive"] }
  serde-wasm-bindgen = "0.6"
  serde_json = "1.0"
  
  # TypeScript type generation
  tsify = "0.4"
  
  # JavaScript types
  js-sys = "0.3"
  
  # Web APIs
  web-sys = { version = "0.3", features = [
      "Request", "RequestInit", "RequestMode", "Response", "Headers",
      "Window", "console"
  ] }
  
  # HTTP client (WASM-compatible)
  reqwest = { version = "0.12", default-features = false, features = ["json"] }
  
  # Async runtime (WASM-compatible)
  tokio = { version = "1", features = ["sync"], default-features = false }
  
  # Error handling
  anyhow = "1.0"
  thiserror = "1.0"
  
  [dev-dependencies]
  wasm-bindgen-test = "0.3"
  
  [profile.release]
  # Optimize for small WASM size
  opt-level = "z"
  lto = true
  codegen-units = 1
  panic = "abort"
  strip = true
  ```
- [ ] Create `src/lib.rs` (entry point)
- [ ] Create `package.json`:
  ```json
  {
    "name": "@rbee/marketplace-sdk",
    "version": "0.1.0",
    "type": "module",
    "description": "Rust SDK for marketplace (HuggingFace, CivitAI, Worker Catalog) that compiles to WASM",
    "main": "./pkg/bundler/marketplace_sdk.js",
    "types": "./pkg/bundler/marketplace_sdk.d.ts",
    "exports": {
      ".": "./pkg/bundler/marketplace_sdk.js"
    },
    "files": ["pkg"],
    "scripts": {
      "build": "wasm-pack build --target bundler --out-dir pkg/bundler",
      "build:web": "wasm-pack build --target web --out-dir pkg/web",
      "build:all": "./build-wasm.sh"
    },
    "keywords": ["rbee", "marketplace", "huggingface", "civitai", "wasm", "rust"],
    "author": "rbee Team",
    "license": "GPL-3.0-or-later"
  }
  ```
- [ ] Create `build-wasm.sh`:
  ```bash
  #!/bin/bash
  # TEAM-400: Build WASM for all targets
  wasm-pack build --target bundler --out-dir pkg/bundler
  wasm-pack build --target web --out-dir pkg/web
  echo "‚úÖ WASM built for all targets"
  ```
- [ ] Run: `chmod +x build-wasm.sh`

### 1.2 Define Types with tsify

**TEAM-400:** Types are auto-generated for TypeScript. NO manual definitions.

- [ ] Create `src/types.rs`:
  ```rust
  // TEAM-400: Marketplace types with tsify for TypeScript generation
  
  use serde::{Deserialize, Serialize};
  use tsify::Tsify;
  use wasm_bindgen::prelude::*;
  
  /// Model from marketplace (HuggingFace or CivitAI)
  /// 
  /// TEAM-400: TypeScript types are AUTO-GENERATED by tsify.
  /// Import from SDK: `import type { Model } from '@rbee/marketplace-sdk'`
  #[derive(Debug, Clone, Serialize, Deserialize, Tsify)]
  #[tsify(into_wasm_abi, from_wasm_abi)]
  pub struct Model {
      pub id: String,
      pub name: String,
      pub description: String,
      pub author: Option<String>,
      pub image_url: Option<String>,
      pub tags: Vec<String>,
      pub downloads: u64,
      pub likes: u64,
      pub size: String,
      pub source: ModelSource,
  }
  
  /// Model source
  #[derive(Debug, Clone, Serialize, Deserialize, Tsify)]
  #[tsify(into_wasm_abi, from_wasm_abi)]
  pub enum ModelSource {
      HuggingFace,
      CivitAI,
  }
  
  /// Worker binary info
  #[derive(Debug, Clone, Serialize, Deserialize, Tsify)]
  #[tsify(into_wasm_abi, from_wasm_abi)]
  pub struct Worker {
      pub id: String,
      pub name: String,
      pub description: String,
      pub version: String,
      pub platform: Vec<String>,
      pub architecture: Vec<String>,
      pub worker_type: WorkerType,
  }
  
  /// Worker type
  #[derive(Debug, Clone, Serialize, Deserialize, Tsify)]
  #[tsify(into_wasm_abi, from_wasm_abi)]
  pub enum WorkerType {
      Cpu,
      Cuda,
      Metal,
  }
  
  /// Model filters
  #[derive(Debug, Clone, Serialize, Deserialize, Tsify)]
  #[tsify(into_wasm_abi, from_wasm_abi)]
  pub struct ModelFilters {
      pub search: Option<String>,
      pub category: Option<String>,
      pub sort: Option<SortOrder>,
      pub limit: Option<u32>,
  }
  
  /// Sort order
  #[derive(Debug, Clone, Serialize, Deserialize, Tsify)]
  #[tsify(into_wasm_abi, from_wasm_abi)]
  pub enum SortOrder {
      Popular,
      Recent,
      Trending,
  }
  ```
- [ ] Export from `src/lib.rs`: `pub use types::*;`

---

## ü§ó Phase 2: HuggingFace Client (Day 1, Afternoon)

### 2.1 Create HTTP Client Module

- [ ] Create `src/huggingface.rs`:
  ```rust
  // TEAM-400: HuggingFace API client (WASM-compatible)
  
  use crate::types::*;
  use anyhow::Result;
  use serde_json::Value;
  use wasm_bindgen::prelude::*;
  
  /// HuggingFace API client
  #[wasm_bindgen]
  pub struct HuggingFaceClient {
      base_url: String,
      api_token: Option<String>,
  }
  
  #[wasm_bindgen]
  impl HuggingFaceClient {
      /// Create new HuggingFace client
      #[wasm_bindgen(constructor)]
      pub fn new(api_token: Option<String>) -> Self {
          Self {
              base_url: "https://huggingface.co/api".to_string(),
              api_token,
          }
      }
      
      /// List models with filters
      pub async fn list_models(&self, filters: Option<ModelFilters>) -> Result<Vec<Model>, JsValue> {
          // TEAM-400: Implement HTTP GET to HuggingFace API
          // Use reqwest with WASM support
          todo!("Implement HuggingFace list_models")
      }
      
      /// Get single model by ID
      pub async fn get_model(&self, id: String) -> Result<Model, JsValue> {
          todo!("Implement HuggingFace get_model")
      }
      
      /// Search models
      pub async fn search_models(&self, query: String) -> Result<Vec<Model>, JsValue> {
          // TEAM-400: Use list_models with search filter
          let filters = ModelFilters {
              search: Some(query),
              category: None,
              sort: None,
              limit: Some(50),
          };
          self.list_models(Some(filters)).await
      }
  }
  
  // TEAM-400: Helper to transform HuggingFace API response to Model
  fn transform_hf_model(data: Value) -> Result<Model> {
      // TEAM-400: Parse HuggingFace JSON and convert to Model struct
      todo!("Implement HuggingFace response transformation")
  }
  ```
- [ ] Export from `src/lib.rs`: `pub use huggingface::HuggingFaceClient;`

### 2.2 Implement reqwest with WASM

- [ ] Study queen-rbee-sdk job-client usage
- [ ] Implement HTTP GET with headers:
  ```rust
  let mut headers = reqwest::header::HeaderMap::new();
  if let Some(token) = &self.api_token {
      headers.insert(
          reqwest::header::AUTHORIZATION,
          format!("Bearer {}", token).parse().unwrap(),
      );
  }
  
  let client = reqwest::Client::new();
  let response = client
      .get(&url)
      .headers(headers)
      .send()
      .await
      .map_err(|e| JsValue::from_str(&e.to_string()))?;
  ```
- [ ] Parse JSON response
- [ ] Transform to Model struct
- [ ] Return Vec<Model>

---

## üé® Phase 3: CivitAI Client (Day 2, Morning)

### 3.1 Create CivitAI Client

- [ ] Create `src/civitai.rs`:
  ```rust
  // TEAM-400: CivitAI API client (WASM-compatible)
  
  use crate::types::*;
  use wasm_bindgen::prelude::*;
  
  /// CivitAI API client
  #[wasm_bindgen]
  pub struct CivitAIClient {
      base_url: String,
      api_token: Option<String>,
  }
  
  #[wasm_bindgen]
  impl CivitAIClient {
      #[wasm_bindgen(constructor)]
      pub fn new(api_token: Option<String>) -> Self {
          Self {
              base_url: "https://civitai.com/api/v1".to_string(),
              api_token,
          }
      }
      
      pub async fn list_models(&self, filters: Option<ModelFilters>) -> Result<Vec<Model>, JsValue> {
          // TEAM-400: Similar to HuggingFaceClient
          todo!("Implement CivitAI list_models")
      }
      
      pub async fn get_model(&self, id: String) -> Result<Model, JsValue> {
          todo!("Implement CivitAI get_model")
      }
      
      pub async fn search_models(&self, query: String) -> Result<Vec<Model>, JsValue> {
          let filters = ModelFilters {
              search: Some(query),
              category: None,
              sort: None,
              limit: Some(50),
          };
          self.list_models(Some(filters)).await
      }
  }
  ```
- [ ] Export from `src/lib.rs`: `pub use civitai::CivitAIClient;`
- [ ] Implement HTTP requests (same pattern as HuggingFace)
- [ ] Transform CivitAI responses to Model struct

---

## üë∑ Phase 4: Worker Catalog Client (Day 2, Afternoon)

**TEAM-400:** HTTP client to talk to rbee-hive's worker endpoints.

### 4.1 Create Worker HTTP Client

- [ ] Create `src/worker_client.rs`:
  ```rust
  // TEAM-400: Worker Catalog HTTP client (talks to rbee-hive)
  
  use crate::types::*;
  use wasm_bindgen::prelude::*;
  
  /// Worker Catalog HTTP client
  #[wasm_bindgen]
  pub struct WorkerClient {
      base_url: String,
  }
  
  #[wasm_bindgen]
  impl WorkerClient {
      /// Create new Worker client
      /// 
      /// base_url: URL to rbee-hive (e.g., "http://localhost:9200")
      #[wasm_bindgen(constructor)]
      pub fn new(base_url: String) -> Self {
          Self { base_url }
      }
      
      /// List all workers
      pub async fn list_workers(&self) -> Result<Vec<Worker>, JsValue> {
          let url = format!("{}/v1/workers", self.base_url);
          // TEAM-400: HTTP GET to rbee-hive
          todo!("Implement worker list")
      }
      
      /// Get single worker by ID
      pub async fn get_worker(&self, id: String) -> Result<Worker, JsValue> {
          let url = format!("{}/v1/workers/{}", self.base_url, id);
          todo!("Implement worker get")
      }
  }
  ```
- [ ] Export from `src/lib.rs`: `pub use worker_client::WorkerClient;`
- [ ] Implement HTTP requests
- [ ] Transform rbee-hive responses to Worker struct

### 4.2 Question: Catalog Contract?

**TEAM-400:** If we need shared types between worker-catalog (desktop) and marketplace SDK:

- [ ] Decide: Create `bin/97_contracts/catalog-contract/`?
- [ ] If yes:
  - [ ] Pure types only (no HTTP logic)
  - [ ] ModelEntry, WorkerBinary types
  - [ ] Enable wasm feature with tsify
  - [ ] marketplace-sdk imports from catalog-contract

**NOTE:** For now, just define types in marketplace-sdk. Can extract to contract later if needed.

---

## üì¶ Phase 5: Build & Export (Day 3)

### 5.1 Complete lib.rs

- [ ] Update `src/lib.rs`:
  ```rust
  // TEAM-400: Marketplace SDK main entry point
  
  #![warn(missing_docs)]
  
  use wasm_bindgen::prelude::*;
  
  // Modules
  mod types;
  mod huggingface;
  mod civitai;
  mod worker_client;
  
  // Re-export types
  pub use types::*;
  
  // Re-export clients
  pub use huggingface::HuggingFaceClient;
  pub use civitai::CivitAIClient;
  pub use worker_client::WorkerClient;
  
  /// Initialize WASM module
  #[wasm_bindgen(start)]
  pub fn init() {
      web_sys::console::log_1(&"üõí [Marketplace SDK] WASM initialized!".into());
  }
  ```

### 5.2 Build WASM

- [ ] Build: `./build-wasm.sh`
- [ ] Verify output:
  ```
  pkg/bundler/
  ‚îú‚îÄ‚îÄ marketplace_sdk.js
  ‚îú‚îÄ‚îÄ marketplace_sdk.d.ts  (TypeScript types AUTO-GENERATED!)
  ‚îú‚îÄ‚îÄ marketplace_sdk_bg.wasm
  ‚îî‚îÄ‚îÄ package.json
  ```
- [ ] Check TypeScript types were generated:
  ```bash
  grep "export interface Model" pkg/bundler/marketplace_sdk.d.ts
  ```

### 5.3 Create README

- [ ] Create `README.md`:
  ```markdown
  # @rbee/marketplace-sdk
  
  **TEAM-400:** Rust SDK for marketplace (HuggingFace, CivitAI, Worker Catalog) that compiles to WASM.
  
  ## Features
  
  - ‚úÖ HuggingFace API client
  - ‚úÖ CivitAI API client
  - ‚úÖ Worker Catalog HTTP client
  - ‚úÖ TypeScript types AUTO-GENERATED (no manual sync!)
  - ‚úÖ Works in Next.js AND Tauri
  
  ## Installation
  
  \`\`\`bash
  pnpm add @rbee/marketplace-sdk
  \`\`\`
  
  ## Usage
  
  ### HuggingFace
  
  \`\`\`typescript
  import { HuggingFaceClient } from '@rbee/marketplace-sdk'
  
  const client = new HuggingFaceClient(apiToken)
  const models = await client.list_models()
  \`\`\`
  
  ### CivitAI
  
  \`\`\`typescript
  import { CivitAIClient } from '@rbee/marketplace-sdk'
  
  const client = new CivitAIClient(apiToken)
  const models = await client.search_models('sdxl')
  \`\`\`
  
  ### Worker Catalog
  
  \`\`\`typescript
  import { WorkerClient } from '@rbee/marketplace-sdk'
  
  const client = new WorkerClient('http://localhost:9200')
  const workers = await client.list_workers()
  \`\`\`
  
  ## TypeScript Types
  
  Types are AUTO-GENERATED from Rust via tsify:
  
  \`\`\`typescript
  import type { Model, Worker, ModelFilters } from '@rbee/marketplace-sdk'
  \`\`\`
  
  ## Architecture
  
  ```
  Rust (marketplace-sdk) ‚Üí wasm-pack ‚Üí WASM + TypeScript types
  ```
  
  - Rust code is the single source of truth
  - TypeScript types are generated automatically
  - No manual type sync needed
  - Same crate works in Next.js AND Tauri
  ```

---

## ‚úÖ Phase 6: Testing (Day 3, Afternoon)

### 6.1 Unit Tests (Rust)

- [ ] Create `src/huggingface.rs` tests:
  ```rust
  #[cfg(test)]
  mod tests {
      use super::*;
      
      #[test]
      fn test_transform_hf_model() {
          // TEAM-400: Test JSON ‚Üí Model conversion
      }
  }
  ```
- [ ] Create tests for CivitAI client
- [ ] Create tests for Worker client
- [ ] Run: `cargo test`

### 6.2 WASM Tests

- [ ] Create `tests/wasm.rs`:
  ```rust
  // TEAM-400: WASM-specific tests
  
  use wasm_bindgen_test::*;
  use marketplace_sdk::*;
  
  #[wasm_bindgen_test]
  fn test_huggingface_client_creation() {
      let client = HuggingFaceClient::new(None);
      assert!(true); // Just verify it compiles
  }
  ```
- [ ] Run: `wasm-pack test --node`

### 6.3 Integration Test (JavaScript)

- [ ] Create `test.js`:
  ```javascript
  import init, { HuggingFaceClient, CivitAIClient, WorkerClient } from './pkg/bundler/marketplace_sdk.js'
  
  await init()
  
  // Test HuggingFace
  const hfClient = new HuggingFaceClient()
  console.log('‚úÖ HuggingFaceClient created')
  
  // Test CivitAI
  const civClient = new CivitAIClient()
  console.log('‚úÖ CivitAIClient created')
  
  // Test Worker
  const workerClient = new WorkerClient('http://localhost:9200')
  console.log('‚úÖ WorkerClient created')
  
  console.log('üéâ All clients work!')
  ```
- [ ] Run: `node test.js`

---

## üìä Success Criteria

### Must Have

- [ ] Rust crate compiles successfully
- [ ] WASM builds successfully with `wasm-pack`
- [ ] TypeScript types are AUTO-GENERATED (check .d.ts file)
- [ ] HuggingFaceClient works (list, get, search)
- [ ] CivitAIClient works (list, get, search)
- [ ] WorkerClient works (list, get)
- [ ] Unit tests pass
- [ ] WASM tests pass
- [ ] Integration test passes

### Nice to Have

- [ ] Error handling with custom error types
- [ ] Retry logic for HTTP requests
- [ ] Caching layer
- [ ] Rate limiting
- [ ] Progress tracking for downloads

---

## üöÄ Deliverables

1. **Rust Crate:** `bin/99_shared_crates/marketplace-sdk/`
2. **WASM Package:** Auto-generated `pkg/` with .js, .d.ts, .wasm
3. **TypeScript Types:** AUTO-GENERATED by tsify
4. **3 Clients:** HuggingFace, CivitAI, Worker
5. **Tests:** Unit, WASM, and integration tests
6. **Documentation:** README with usage examples

---

## üìù Notes

### Key Principles

1. **RUST FIRST** - Rust is the single source of truth
2. **WASM-COMPATIBLE** - Uses reqwest with WASM support
3. **AUTO-GENERATED TYPES** - tsify generates TypeScript types
4. **SINGLE CRATE** - Works in both Next.js AND Tauri
5. **FOLLOW PATTERN** - Same as queen-rbee-sdk

### Common Pitfalls

- ‚ùå Don't create TypeScript types manually (tsify does it!)
- ‚ùå Don't use non-WASM-compatible crates (tokio default features, std::fs)
- ‚ùå Don't forget #[wasm_bindgen] on public structs/functions
- ‚ùå Don't use blocking I/O (use async/await)
- ‚úÖ Use tsify for all types
- ‚úÖ Use reqwest with default-features = false
- ‚úÖ Follow queen-rbee-sdk pattern exactly
- ‚úÖ Test WASM builds frequently

### Debugging WASM

```bash
# Build and check output
./build-wasm.sh

# Check generated types
cat pkg/bundler/marketplace_sdk.d.ts | grep "export"

# Test in Node
node test.js

# Check WASM size
ls -lh pkg/bundler/*.wasm
```

---

**Start with Phase 1, follow queen-rbee-sdk pattern!** ‚úÖ

**TEAM-400 üêùüéä**
