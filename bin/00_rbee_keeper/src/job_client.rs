//! Job submission client for queen-rbee
//!
//! This is the ONLY way rbee-keeper talks to queen-rbee:
//! 1. Ensure queen is running
//! 2. POST /v1/jobs with operation payload
//! 3. GET /jobs/{job_id}/stream and stream narration to stdout
//! 4. Cleanup queen handle
//!
//! TEAM-185: Updated narration to use operation field instead of embedding in human message
//! TEAM-185: Added hive_id to narration context
//! TEAM-185: Replaced hardcoded action strings with constants from operations module
//! TEAM-186: Accept Operation directly, serialize internally (DRY)
//! TEAM-216: Investigated - Complete behavior inventory created
//! TEAM-259: Refactored to use job-client shared crate

use anyhow::Result;
use job_client::JobClient;
use observability_narration_core::n;
use operations_contract::Operation; // TEAM-284: Renamed from rbee_operations
use std::time::Duration;
use timeout_enforcer::TimeoutEnforcer;

/// Submit a job and stream its narration output.
///
/// TEAM-186: Now accepts Operation directly instead of pre-serialized JSON
/// TEAM-259: Simplified to use shared JobClient
/// TEAM-318: Removed auto-start + eliminated duplication
/// TEAM-385: Added Ctrl+C cancellation support
///
/// Works with any HTTP endpoint (queen or hive).
///
/// - Submits the job with 10-second timeout
/// - Streams SSE narration events with timeout (30s or 10min for downloads)
/// - Cancellable with Ctrl+C
/// - Fails if target is not running
pub async fn submit_and_stream_job(target_url: &str, operation: Operation) -> Result<()> {
    // Note: correlation_id is generated by target if not provided
    // Clients CAN optionally provide one, but it's not required

    // Extract metadata before moving operation
    let operation_name = operation.name();
    let hive_id = operation.hive_id().map(|s| s.to_string());

    n!("job_submit", "üìã Job submitted: {}", operation_name);

    // Wrap SSE streaming with timeout
    // TEAM-385: Model downloads can take several minutes, use longer timeout
    // TEAM-388: Worker installation (cargo build) can take 10-15 minutes
    let timeout_secs = match operation_name {
        "model_download" => 600,  // 10 minutes for model downloads
        "worker_install" => 900,  // 15 minutes for worker builds (cargo can be slow)
        _ => 30,  // 30 seconds for other operations
    };
    
    // TEAM-387: Simpler approach - spawn streaming task, get job_id via channel
    let (job_id_tx, job_id_rx) = tokio::sync::oneshot::channel();
    let target_url_clone = target_url.to_string();
    
    let stream_task = tokio::spawn(async move {
        let result = submit_and_stream_with_id_callback(
            &target_url_clone,
            operation,
            operation_name,
            job_id_tx
        ).await;
        
        result
    });
    
    // Wait for job_id (should be immediate)
    let job_id = job_id_rx.await.map_err(|_| anyhow::anyhow!("Failed to get job_id"))?;
    
    // TEAM-385: Make cancellable with Ctrl+C
    // TEAM-387: Now we have job_id, can send cancel request
    let timeout_future = TimeoutEnforcer::new(Duration::from_secs(timeout_secs))
        .with_label("Streaming job results")
        .silent() // Don't show countdown - narration provides feedback
        .enforce(async { stream_task.await? });
    
    tokio::select! {
        result = timeout_future => result,
        _ = tokio::signal::ctrl_c() => {
            // TEAM-387: Send cancel request to server
            n!("job_cancelling", "üõë Cancelling operation...");
            
            // Send DELETE request to cancel endpoint
            let cancel_url = format!("{}/v1/jobs/{}", target_url, job_id);
            let client = reqwest::Client::new();
            let _ = client
                .delete(&cancel_url)
                .timeout(Duration::from_secs(2))
                .send()
                .await; // Best effort - ignore errors
            
            n!("job_cancelled", "üõë Operation cancelled by user");
            Err(anyhow::anyhow!("Operation cancelled by user"))
        }
    }
}

/// Submit job directly to hive (no queen) and stream results
///
/// TEAM-314: For operations that talk directly to hive (HiveCheck, HiveStatus)
/// TEAM-318: Now just an alias for submit_and_stream_job (same implementation)
#[inline]
pub async fn submit_and_stream_job_to_hive(hive_url: &str, operation: Operation) -> Result<()> {
    submit_and_stream_job(hive_url, operation).await
}

/// Submit job and stream, sending job_id via channel
///
/// TEAM-387: Helper for cancellation support - sends job_id immediately via channel
async fn submit_and_stream_with_id_callback(
    queen_url: &str,
    operation: Operation,
    operation_name: &'static str,
    job_id_tx: tokio::sync::oneshot::Sender<String>,
) -> Result<()> {
    n!("job_stream", "üì° Streaming results for {}", operation_name);

    // TEAM-259: Use shared JobClient for submission and streaming
    // TEAM-387: RULE ZERO - API changed to return (job_id, stream_future)
    let job_client = JobClient::new(queen_url);

    let (job_id, stream_future) = job_client
        .submit_and_stream(operation, {
            // TEAM-387: Move captured variables into closure
            let mut job_failed = false; // TEAM-189: Track job failures to show proper final status
            move |line| {
                // Just print the data directly without wrapping in narration
                println!("{}", line);

                // TEAM-189: Track if the job failed
                if line.contains("failed:") || (line.contains("Job") && line.contains("failed")) {
                    job_failed = true;
                }

                // Check for [DONE] marker
                if line.contains("[DONE]") {
                    // TEAM-189: Show ‚ùå Failed for failures, ‚úÖ Complete for successes
                    if job_failed {
                        n!("job_complete", "‚ùå Failed: {}", operation_name);
                    } else {
                        n!("job_complete", "‚úÖ Complete: {}", operation_name);
                    }
                }

                Ok(())
            }
        })
        .await?;

    // TEAM-387: Send job_id immediately via channel
    let _ = job_id_tx.send(job_id);

    // TEAM-387: Await the stream future
    stream_future.await?;

    Ok(())
}
